# Conclusion for the meeting 06-24

## 1. Optimization purpose

Generally, we have two parts of work : 
1. rewrite and optimize the michelson program/contract in terms of its consumed gas
2. prove the equivalent of those two contract by preserved input-output relationships

After these, to use the translation validation for our condidates and prove the programs are equivalent.

For our program, the input and output should be Michelson programs, the only difference is that the output program consumes less gas.

## 2. Rewriting rules of datatypes

We already have the abstract syntax tree of Michelson language, which is defined inside of script_ir or typed_ir files.

To implement the Michelson AST, there are two possible solutions.
First, find a way to rewrite well-typed michelson program, but we can only define type-preserving rewriting rules, which makes the rewriting rules diffcult.
Another solution is using micheline representation, which doesn't have the type-preserving contraints, but it may generate more wrong contracts.

## 3. S-metaheuristics

The exploration algorithm is the most important part, the core of our program. The node of the searching graph should be well-typed michelson programs represented by the pre-defined AST in the codebase of Tezos.

**(I am not sure that the following paragraph is perfectly correct)**
The process should be : given the initial program as the input, we use the rewriting rules to rewrite it and get many programs in the space (Remember to make sure they are well-typed). The rewrite rules should be defined in the S-metaheuristics methods, they are actually the mutation/pertupation steps of the Searching Algorithm. Using ILS, for example, we could find where(which node) to rewrte and obtain a better program in a faster speed.

Basically, we have two filters after the searching and rewriting. One is the input-output relationships, only the programs that have the same relationships can become the condidates. Then we need to check if the gas consuming is less. The candidates will less gas consuming will be kept.

We may need large set of candidates, because many of them might not be semantically equivalent.

In this point of view, the output should be a set of candidates of michelson program consuming less gas.


## 4. The whole Process

1. parse the source program
2. several basic rewriting rules
    - firstly, start with some deterministic rules and prepare the instructions for candidates generation
    - consider the randomness and more sophisticated methods (maybe later)
3. implement the process of exploring the graph generated by these rules
    - filter the candidates by preserving input-output relationships
    - continue the exploration through the candidates by consuming gas
    - stop when you cannot improve the score of the best candidate

Further step translation validation to select a sound solution in the set of best candidates.

