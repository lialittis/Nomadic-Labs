# date [04-05-2021]

## TODO

- [x] make the path for hacking the generator
- [x] talk with Yann
- [x] code and test


## Review

### Code Review

Starting from test_sampling_data.ml, the work trace will be:

1. instantialize MCMC
	- Michelson_samplers_base.Make_full by a module type of S, which contains three parameters: parameters, siwe, algo. **Here we need to add one more parameter called type**;
	- If we add more arguments to S, then we have to modify the related functions;
	- If not, we could consider that add one more parameter of type in Data Generation Part; For Generators.Data, it needs a *Samplers* module, a random state, a target siwe and a verbosity setting;

2. inside generators
	- initial part : to add a type constraint,  we need to go inside of *Inference* Module and modify it;
-> **q1: what is snd**
-> **q2: how to add this type constraint**
-> look at Sampler.ml and State_space.ml
	- energy part : which we don't really care about
	- rewriting rules : 

3. State and sampler

The type t of *State_space* module is `{typing : Inference.state lazy_t; term : Mikhailsky.node}`, so we could get the point that, the typing element could be generated by `infer_data_with_state` according to the term.

What we need to change is to modify the proposal kernel of sampler, more precisely, we need to change the rewriting_options.


4. Rewriting rules

*Rewrite_rules* in generators is acctually from *Rules* Module's *Data_rewrite_leaves* function.
In this function, multiple matches are built;

*Rewriting* function :
- inputs : current state and rules;
- for each rule, compute all possible matches of rule on your term;
- for each match, check it by filter_matches;
- for each match which is ok, perform rewriting;
- let Markov Chain decide which rewriting you are going to pick.

```
let filter_matches typing guard matches =
  List.filter (evaluate_guard typing guard) matches
```
```
let evaluate_guard_monadic guard path =
  let open Inference.M in
  match guard with
  | No_cnstrnt ->
      return ()
  | Data_cnstrnt {cnstrnt = base_type_constraint; fresh} -> (
      add_fresh_data_variables fresh
      >>= fun () ->
      get_data_annot path
      >>= fun res_opt ->
      match res_opt with
      | None ->
          assert false
      | Some type_of_expr ->
          Inference.unify_base type_of_expr base_type_constraint
          >>= fun () ->
          Inference.instantiate_base type_of_expr >>= fun _ -> return () )
  | Instr_cnstrnt {cnstrnt = {bef = pre; aft = post}; fresh; fresh_stack} -> (
      (* Add base fresh type variables *)
      add_fresh_variables fresh base_repr cmp_repr
      >>= fun () ->
      add_fresh_stack_variables fresh_stack
      >>= fun () ->
      get_instr_annot path
      >>= fun res_opt ->
      match res_opt with
      | None ->
          assert false
      | Some {bef; aft} ->
          Inference.unify pre bef
          >>= fun () ->
          Inference.unify post aft
          >>= fun () ->
          Inference.instantiate bef
          >>= fun _bef -> Inference.instantiate aft >>= fun _aft -> return () )

let evaluate_guard typing guard path =
  try
    let _ = evaluate_guard_monadic guard path typing in
    true
  with Inference.Ill_typed_script _ -> false
```


where guard is the type_constraint, it should contain the target_type and we could set the 
filter there.


### What I did

I. In test_sampming_data.ml

1. add global_type 
2. call Generator.Data with module containing target_type = global_type

II. In generators.ml

1. set target_type as type of *Script_repr.expr* into the Functor X
2. Call *Sampler.Make* to one module with *initial*, *energy* and *rules*, etc
(which we don't need to change, as far as I known, or at least we need to add target
type as the type constraint)


III. In Sampler.ml

1. Modify *proposal* function inside of Make module

**Analysis:**

The type of rewriting_options is *(Mikhailsky.Path.t * Mikhailsky.node) list*, it is
rewrited by *rewriting* function in rules.ml

IV. In rules.ml

In the rewriting function, we want to filter all the matches to the matches which follow the type_constraint. So the key is to modify *filter_matches* function.

[To be continue]

### Supplement

- [ ] Functor of OCaml
- [ ] Type inference algorithm
- [ ] state in monad programming


## Conclusion

### Achievements in general


### Dissatisfaction
